# Работа с баттнмапами
## Описание таблицы ButtonMap
* `pos` - Положение баттнмапы относительно координат вагона
* `ang` - Угол поворота баттнмапы относительно вагона
* `width` - Ширина баттнмапы
* `height` - Высота баттнмапы
* `scale` - Коэффицент размера баттнмапы
* `sensor` -  Является ли данная баттнмапа плоскостью, которая будет передавать координаты нажатий в систему `system`
* `system` -  см. `sensor`
* `hide` - если данное значение задано, то оно будет использованно как коэффицент для дальности прорисовки.
* `hideseat` -  если данное значение задано, то оно будет использованно как коэффицент для дальности прорисовки, но только если человек сидит в сиденье, не пренадлежащем данному вагону
* `buttons`: таблица с описанием кнопок
    * `ID` - ID кнопки
    * `x` - x координата кнопки относительно баттнмапы
    * `y` - y координата кнопки относительно баттнмапы
    * `radius` - радиус зоны взаимодействия, используется если `w` или `h` не заданы
    * `w` - ширина зоны взаимодействия
    * `h` - высота зоны взаимодействия
    * `tooltip` - подпись для кнопки.
    * `model`: таблица с описанием модели кнопки
        * `name` - имя модели кнопки. Стандартное значение - ID кнопки
        * `model` - путь до модели кнопки. Стандартное значение - `models/metrostroi/81-717/button07.mdl`
        * `pos` - позиция модели кнопки относительно позиции кнопки.
        * `ang` - угол поворота кнопки относительно баттнмапы.
        * `color` - цвет модели кнопки
        * `colora` - цвет модели кнопки с альфа-каналом. Имеет больший приоритет, чем простой `color`
        * `skin` - скин модели кнопки
        * `hide` - если данное значение задано, то оно будет использованно как коэффицент для дальности прорисовки.
        * `hideseat` - если данное значение задано, то оно будет использованно как коэффицент для дальности прорисовки, но только если человек сидит в сиденье, не пренадлежащем данному вагону
        * `scale` - масштаб модели кнопки
        * `bscale` - масштаб кости с id=0. Подробнее можно узнать из метода `Entity:ManipulateBoneScale`
        * `vmin` - минимальное значение для активации анимации
        * `vmax` - максимальное значение для активации анимации
        * `min` - значение начала анимации
        * `max` - значение конца анимации
        * `speed` - скорость анимации
        * `damping` - демпфирование анимации
        * `stickyness` - "прилипчивость" анимации
        * `var` - сетевая переменная, которая будет использована для активации данной анимации
        * `getfunc` - функция, используемая для получения состояния аниамации. Получает энтити вагона, vmin, vmax, var. Возвращает bool
        * `disable` - если эта кнопка будет включена, тогда кнопка с этим именем будет спрятана. Полезно для крышек.
        * `disableinv` - тоже самое, что и `disable`, но инвертированное
        * `disableoff` и `disableon` - если текущая кнопка выключена, тогда кнопка с именем `disableoff` будет спрятана. Если текущая кнопка включена, тогда кнопка с именем `disableon` будет спрятана.
        * `disablevar` - если эта сетевая переменная будет равна `true`, тогда эта кнопка будет скрыта
        * `sndid` - ID звука. По умолчанию равен ID кнопки
        * `sndvol` - громкость звука. По умолчанию равна 1
        * `sndpitch` - высота звука. По умолчанию равна 1
        * `sndmin` - минимальная дистанция, от которого данный звук будет проигран. По умолчанию равен 100
        * `sndmax` - максимальная дистанция, до которого данный звук будет проигран. По умолчанию равен 1000
        * `sndang` - угол, под которым данный звук будет проигран. По умолчанию равен `Angle(0, 0, 0)`
        * `snd` - функция. Получает булево значение сетевой переменной (выражение `var > 0`) и сырую переменную. Должна вернуть ID звука, который необходимо проиграть.
        * `plomb`: таблица, описывающия пломбу
            * все переменные, описывающие модель (pos, z, x, y, ang, color, skin, hide, hideseat, bscale, scale) как в таблице model И
            * `var` - сетевая переменная, которая будет переключать данную пломбу
        * `lamp`: таблица, описывающая лампочку
            * все переменные, описывающие модель (pos, z, x, y, ang, color, skin, hide, hideseat, bscale, scale) как в таблице model И
            * `anim` - флаг, обозначающий то, нужно ли анимировать данную лампочку ровно также, как и модель кнопки
            * `var` - сетевая переменная, управляющая анимайцией данной лампочки
            * `min` - значение начала анимации
            * `max` - значение конца анимации
            * `speed` - скорость анимации
            * `getfunc` - функция, используемая для получения состояния аниамации. Получает энтити вагона, vmin, vmax, var. Возвращает bool
            * `hidden` -  ¯\\_(ツ)_/¯
        * `lamps`: таблица с множеством объектов, описывающих лампы. Имеют формат как таблица `lamp`.
        * `labels`: таблица с множеством объектов, описывающих "подписи". Объекты содержат все переменные описывающие модель (pos, z, x, y, ang, color, skin, hide, hideseat, bscale, scale) как в таблице model. Позволяет добавить статичные модели (модели, которые не будут зависимы от какой либо сетевой переменной)

## Изменение существующих баттнмап
### MEL.MoveButtonMap - передвинуть баттнмапу
`MEL.MoveButtonMap(ent, buttonmap_name, new_pos, new_ang)` - передвигает баттнмапу и пересоздает её клиентские пропы

*(scope: Client)*

* `ent` - энтити вагона
* `buttonmap_name` - имя баттнмапы
* `[new_pos]` - новое положение баттнмапы
* `[new_ang]` - новый поворот баттнмапы


**Пример использования**:
```lua
-- только передвинуть
MEL.MoveButtonMap(ent, "SomeButtonMap", Vector(0, 0, 0))


-- только покрутить
MEL.MoveButtonMap(ent, "OtherButtonMap", nil, Angle(0, 0, 0))


-- и передвинуть, и покрутить
MEL.MoveButtonMap(ent, "AnotherButtonMap", Vector(420, 69, 228), Angle(0, 0, 0))
```


### MEL.MoveButtonMapButton - передвинуть кнопку в баттнмапе
`MEL.MoveButtonMapButton(ent, buttonmap_name, button_name, x, y)` - передвигает отдельную кнопку в баттнмапе

*(scope: Client)*

* `ent` - энтити вагона
* `buttonmap_name` - имя баттнмапы
* `buttonmap_name` - имя (ID) баттнмапы
* `[x]` - новое положение по координате X
* `[y]` - новый положение по координате Y


**Пример использования**:
```lua
-- передвинуть только по X
MEL.MoveButtonMapButton(ent, "SomeButtonMap", "SomeButton", 10)

-- передвинуть только по Y
MEL.MoveButtonMapButton(ent, "SomeButtonMap", "SomeButton", nil, 10)

-- передвинуть по X и Y
MEL.MoveButtonMapButton(ent, "SomeButtonMap", "SomeButton", 10, 10)
```


### MEL.ModifyButtonMap - контекст для изменения баттнмапы и её кнопок
`MEL.ModifyButtonMap(ent, buttonmap_name, buttonmap_callback, button_callback)` - позволяет изменить любой параметр в самой баттнмапе и каждой отдельной кнопке

*(scope: Client)*

* `ent` - энтити вагона
* `buttonmap_name` - имя баттнмапы
* `[buttonmap_callback]` - функция, которая должна изменить баттнмапу. Принимает ссылку на таблицу баттнмапы
* `[button_callback]` - функция, которая должна изменить отдельные кнопки. Принимает ссылку на таблицу кнопки. Вызывается на каждую кнопку

**Пример использования**:
```lua
-- меняем положение баттнмапы, поворот всех кнопок и их модель. Для отдельных кнопок указываем нестандартную модель
MEL.ModifyButtonMap(ent, "Battery_C", function(buttonmap)
    buttonmap.pos = Vector(408.4, -63, 18)
end, function(button)
        button.model.ang = Angle(0, 90, 270)
        button.model.model = MODELS_ROOT .. "panels/packswitch_square.mdl"
        if button.ID == "1:VBToggle" then
            button.model.model = MODELS_ROOT .. "panels/packswitch_VB-13B.mdl"
        end
    end
end)
```

### MEL.NewButtonMapButton - добавить кнопку в существующую баттнмапу
`MEL.NewButtonMapButton(ent, buttonmap_name, button_data)` - добавляет новую кнопку в уже существующую баттнмапу

*(scope: Client)*

* `ent` - энтити вагона
* `buttonmap_name` - имя баттнмапы
* `button_data` - описание кнопки


**Пример использования**:
```lua
MEL.NewButtonMapButton(ent, "Battery_R", {
    ID = "2:VPRToggle",
    x = 220 + 140,
    y = 40,
    radius = 40,
    tooltip = "",
    model = {
        model = MODELS_ROOT .. "panels/packswitch_VTR.mdl",
        z = -6.5,
        ang = Angle(0, 90, 270),
        var = nil,
        speed = 0.5,
        vmin = 1,
        vmax = 0.87,
        sndvol = 0.8,
        snd = function(val) return val and "pak_on" or "pak_off" end,
        sndmin = 80,
        sndmax = 1e3 / 3,
        sndang = Angle(-90, 0, 0),
    }
})
```

### MEL.OverrideHidePanel - перезаписать логику HidePanel для баттнмапы
/// admonition
    type: tip

Данную функцию стоит использовать, если вам необходимо изменить поведение ранее вызванной функции HidePanel (допустим, если она вызывается в стандартном Think метростроя)
///
`MEL.OverrideHidePanel(ent, buttonmap_name, value_callback)` - позволяет изменить логику для функции HidePanel, которую уже вызывали до этого в коде для этой баттнмапы

*(scope: Client)*

* `ent` - энтити вагона
* `buttonmap_name` - имя баттнмапы
* `value_callback` - функция, принимающая энтити вагона, которая должна возврашать true или false в зависимости от того, необходимо ли скрывать данную баттнмапу

**Пример использования**:
```lua
-- не даем стандартному коду метростроя скрывать DriverValveDisconnect,
-- если сетевая переменная DrawDriverValveDisconnect - true
MEL.OverrideHidePanel(ent, "DriverValveDisconnect", function(ent)
    if ent:GetNW2Bool("DrawDriverValveDisconnect") then
        return false
    else
        return true
    end
end)
```

## MEL.NewButtonMap - создать новую баттнмапу
`MEL.NewButtonMap(ent, buttonmap_name, buttonmap_data, do_not_override)` - создает новую баттнмапу

*(scope: Client)*

* `ent` - энтити вагона
* `buttonmap_name` - имя баттнамапы
* `buttonmap_data` - описание баттнмапы
* `[do_not_override]` - вызывать ли ошибку если баттнмапа с таким названием уже создана?

**Пример использования**:
```lua
MEL.NewButtonMap(ent, "CabinFusePanel_dot5", {
    pos = Vector(430.4, -63.8, -5.8),
    ang = Angle(0, 180, 90),
    width = 300,
    height = 300,
    scale = 0.0625,
    buttons = {
        {
            ID = "P_11KToggle",
            x = 0,
            y = 0,
            w = 40,
            h = 100,
            tooltip = "",
            model = {
                model = MODELS_ROOT .. "bp15.mdl",
                ang = 90,
                x = -1,
                y = 45,
                z = -2,
            }
        },
    }
})
```


## MEL.AddToSyncTable - добавить сетевую переменную в таблицу синхронизации
`MEL.AddToSyncTable(ent, sync_key)` - добавляет сетевую переменную в таблицу синхронизации

*(scope: SERVER)*

* `ent` - энтити вагона
* `sync_key` - имя сетевой переменной

**Пример использования**:
```lua
MEL.AddToSyncTable(ent, "SomeNW2Var")
```
